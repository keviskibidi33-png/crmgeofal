# üìÅ Sistema de Archivado de Comprobantes de Pago - Documentaci√≥n Completa

## üéØ Resumen del Sistema

El sistema de archivado permite a los usuarios de facturaci√≥n y administradores archivar comprobantes de pago aprobados para mantener la interfaz organizada y limpia. Los comprobantes archivados se pueden desarchivar cuando sea necesario.

## üóÑÔ∏è Estructura de Base de Datos

### Tabla: `payment_proofs` (Modificada)

**Columnas agregadas para archivado:**
```sql
-- Columnas de archivado
archived BOOLEAN DEFAULT FALSE,           -- Indica si est√° archivado
archived_at TIMESTAMP,                   -- Fecha de archivado
archived_by INTEGER REFERENCES users(id) -- Usuario que archiv√≥
```

**√çndices creados:**
```sql
CREATE INDEX idx_payment_proofs_archived ON payment_proofs (archived);
CREATE INDEX idx_payment_proofs_archived_at ON payment_proofs (archived_at);
CREATE INDEX idx_payment_proofs_archived_by ON payment_proofs (archived_by);
```

## üîß Backend - Implementaci√≥n

### 1. Modelo (`backend/models/paymentProof.js`)

**Funciones agregadas:**

#### `archivePaymentProof(proofId, archivedBy)`
```javascript
async archivePaymentProof(proofId, archivedBy) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    const result = await client.query(`
      UPDATE payment_proofs 
      SET 
        archived = TRUE,
        archived_at = NOW(),
        archived_by = $1,
        updated_at = NOW()
      WHERE id = $2 AND status = $3 AND (archived IS NULL OR archived = FALSE)
      RETURNING *
    `, [archivedBy, proofId, this.STATUS.APPROVED]);
    
    if (result.rows.length === 0) {
      throw new Error('Comprobante no encontrado, no est√° aprobado o ya est√° archivado');
    }
    
    await client.query('COMMIT');
    return result.rows[0];
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

#### `unarchivePaymentProof(proofId)`
```javascript
async unarchivePaymentProof(proofId) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    const result = await client.query(`
      UPDATE payment_proofs 
      SET 
        archived = FALSE,
        archived_at = NULL,
        archived_by = NULL,
        updated_at = NOW()
      WHERE id = $1
      RETURNING *
    `, [proofId]);
    
    if (result.rows.length === 0) {
      throw new Error('Comprobante no encontrado');
    }
    
    await client.query('COMMIT');
    return result.rows[0];
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

#### `getArchivedProofs(filters = {})`
```javascript
async getArchivedProofs(filters = {}) {
  let whereClause = 'WHERE pp.archived = TRUE';
  let params = [];
  let paramCount = 0;
  
  // Filtros de fecha
  if (filters.date_from) {
    paramCount++;
    whereClause += ` AND pp.archived_at >= $${paramCount}`;
    params.push(filters.date_from);
  }
  
  if (filters.date_to) {
    paramCount++;
    whereClause += ` AND pp.archived_at <= $${paramCount}`;
    params.push(filters.date_to);
  }
  
  // Filtro por usuario que archiv√≥
  if (filters.archived_by) {
    paramCount++;
    whereClause += ` AND pp.archived_by = $${paramCount}`;
    params.push(filters.archived_by);
  }
  
  const result = await pool.query(`
    SELECT 
      pp.*,
      q.quote_number,
      q.total_amount,
      q.project_id,
      p.name as project_name,
      c.name as company_name,
      c.ruc as company_ruc,
      u.name as uploaded_by_name,
      u.email as uploaded_by_email,
      archiver.name as archived_by_name
    FROM payment_proofs pp
    JOIN quotes q ON pp.quote_id = q.id
    LEFT JOIN projects p ON q.project_id = p.id
    LEFT JOIN companies c ON p.company_id = c.id
    LEFT JOIN users u ON pp.uploaded_by = u.id
    LEFT JOIN users archiver ON pp.archived_by = archiver.id
    ${whereClause}
    ORDER BY pp.archived_at DESC
  `, params);
  
  return result.rows;
}
```

#### `getApprovedProofs()` (Modificada)
```javascript
// Excluye comprobantes archivados
WHERE pp.status = $1 AND (pp.archived IS NULL OR pp.archived = FALSE)
```

### 2. Controlador (`backend/controllers/paymentProofController.js`)

**Funciones agregadas:**

#### `archivePaymentProof`
```javascript
exports.archivePaymentProof = async (req, res) => {
  try {
    const { proofId } = req.params;
    const userId = req.user.id;
    
    const proof = await PaymentProof.archivePaymentProof(proofId, userId);
    
    res.json({
      success: true,
      message: 'Comprobante archivado exitosamente',
      data: proof
    });
  } catch (error) {
    console.error('‚ùå Error archiving payment proof:', error);
    res.status(500).json({ error: error.message });
  }
};
```

#### `unarchivePaymentProof`
```javascript
exports.unarchivePaymentProof = async (req, res) => {
  try {
    const { proofId } = req.params;
    
    const proof = await PaymentProof.unarchivePaymentProof(proofId);
    
    res.json({
      success: true,
      message: 'Comprobante desarchivado exitosamente',
      data: proof
    });
  } catch (error) {
    console.error('‚ùå Error unarchiving payment proof:', error);
    res.status(500).json({ error: error.message });
  }
};
```

#### `getArchivedProofs`
```javascript
exports.getArchivedProofs = async (req, res) => {
  try {
    const filters = req.query;
    const proofs = await PaymentProof.getArchivedProofs(filters);
    
    res.json(proofs);
  } catch (error) {
    console.error('‚ùå Error getting archived proofs:', error);
    res.status(500).json({ error: error.message });
  }
};
```

### 3. Rutas (`backend/routes/paymentProofRoutes.js`)

**Rutas agregadas:**
```javascript
// Obtener comprobantes archivados
router.get('/archived', paymentProofController.getArchivedProofs);

// Archivar comprobante
router.put('/:proofId/archive', paymentProofController.archivePaymentProof);

// Desarchivar comprobante
router.put('/:proofId/unarchive', paymentProofController.unarchivePaymentProof);
```

## üé® Frontend - Implementaci√≥n

### 1. Estado y Funciones (`frontend/src/pages/ComprobantesPago.jsx`)

**Estados agregados:**
```javascript
const [archivedProofs, setArchivedProofs] = useState([]);
const [archivingProofs, setArchivingProofs] = useState(new Set());
```

**Funci√≥n de archivado optimizada:**
```javascript
const handleArchive = async (proofId) => {
  if (window.confirm('¬øEst√°s seguro de que quieres archivar este comprobante? Se mover√° al archivo y no aparecer√° en la lista principal.')) {
    try {
      // Marcar como procesando
      setArchivingProofs(prev => new Set([...prev, proofId]));
      
      const response = await api(`/api/payment-proofs/${proofId}/archive`, {
        method: 'PUT'
      });
      
      // Actualizar estado local inmediatamente
      const proofToArchive = approvedProofs.find(proof => proof.id === proofId);
      if (proofToArchive) {
        // Remover de comprobantes aprobados
        setApprovedProofs(prev => prev.filter(proof => proof.id !== proofId));
        
        // Agregar a comprobantes archivados con datos actualizados
        const archivedProof = {
          ...proofToArchive,
          archived: true,
          archived_at: new Date().toISOString(),
          archived_by_name: user.name
        };
        setArchivedProofs(prev => [archivedProof, ...prev]);
      }
      
      setSuccess('Comprobante archivado exitosamente');
    } catch (err) {
      console.error('Error archiving proof:', err);
      setError('Error al archivar el comprobante: ' + (err.message || 'Error desconocido'));
    } finally {
      // Remover del estado de procesando
      setArchivingProofs(prev => {
        const newSet = new Set(prev);
        newSet.delete(proofId);
        return newSet;
      });
    }
  }
};
```

**Funci√≥n de desarchivado optimizada:**
```javascript
const handleUnarchive = async (proofId) => {
  if (window.confirm('¬øEst√°s seguro de que quieres desarchivar este comprobante? Volver√° a aparecer en la lista de comprobantes aprobados.')) {
    try {
      // Marcar como procesando
      setArchivingProofs(prev => new Set([...prev, proofId]));
      
      const response = await api(`/api/payment-proofs/${proofId}/unarchive`, {
        method: 'PUT'
      });
      
      // Actualizar estado local inmediatamente
      const proofToUnarchive = archivedProofs.find(proof => proof.id === proofId);
      if (proofToUnarchive) {
        // Remover de comprobantes archivados
        setArchivedProofs(prev => prev.filter(proof => proof.id !== proofId));
        
        // Agregar a comprobantes aprobados con datos actualizados
        const unarchivedProof = {
          ...proofToUnarchive,
          archived: false,
          archived_at: null,
          archived_by_name: null
        };
        setApprovedProofs(prev => [unarchivedProof, ...prev]);
      }
      
      setSuccess('Comprobante desarchivado exitosamente');
    } catch (err) {
      console.error('Error unarchiving proof:', err);
      setError('Error al desarchivar el comprobante: ' + (err.message || 'Error desconocido'));
    } finally {
      // Remover del estado de procesando
      setArchivingProofs(prev => {
        const newSet = new Set(prev);
        newSet.delete(proofId);
        return newSet;
      });
    }
  }
};
```

### 2. Interfaz de Usuario

**Bot√≥n de Archivar (con indicador de progreso):**
```javascript
<Button 
  variant="outline-warning" 
  size="sm"
  onClick={() => handleArchive(proof.id)}
  disabled={archivingProofs.has(proof.id)}
>
  {archivingProofs.has(proof.id) ? (
    <>
      <Spinner animation="border" size="sm" className="me-1" />
      Archivando...
    </>
  ) : (
    <>
      <FiArchive className="me-1" />
      Archivar
    </>
  )}
</Button>
```

**Bot√≥n de Desarchivar (con indicador de progreso):**
```javascript
<Button 
  variant="outline-success" 
  size="sm"
  onClick={() => handleUnarchive(proof.id)}
  disabled={archivingProofs.has(proof.id)}
>
  {archivingProofs.has(proof.id) ? (
    <>
      <Spinner animation="border" size="sm" className="me-1" />
      Desarchivando...
    </>
  ) : (
    <>
      <FiRefreshCw className="me-1" />
      Desarchivar
    </>
  )}
</Button>
```

**Secci√≥n de Comprobantes Archivados:**
```javascript
{(user.role === 'facturacion' || user.role === 'admin') && (
  <Row className="mt-4">
    <Col>
      <Card>
        <Card.Header>
          <h5 className="mb-0">
            <FiArchive className="me-2" />
            Comprobantes Archivados ({archivedProofs.length})
          </h5>
        </Card.Header>
        <Card.Body>
          {archivedProofs.length === 0 ? (
            <p className="text-muted text-center">No hay comprobantes archivados</p>
          ) : (
            <div className="list-group list-group-flush">
              {archivedProofs.map((proof) => (
                <div key={proof.id} className="list-group-item">
                  <div className="d-flex justify-content-between align-items-start">
                    <div>
                      <h6 className="mb-1">Cotizaci√≥n: {proof.quote_number}</h6>
                      <p className="mb-1 text-muted">
                        <strong>Empresa:</strong> {proof.company_name}<br/>
                        <strong>Monto:</strong> ${proof.amount_paid?.toLocaleString()}<br/>
                        <strong>M√©todo:</strong> {proof.payment_method}<br/>
                        <strong>Fecha de pago:</strong> {new Date(proof.payment_date).toLocaleDateString()}<br/>
                        <strong>Archivado por:</strong> {proof.archived_by_name}<br/>
                        <strong>Fecha de archivado:</strong> {new Date(proof.archived_at).toLocaleDateString()}
                      </p>
                    </div>
                    <div className="d-flex flex-column gap-2">
                      <Button 
                        variant="outline-primary" 
                        size="sm"
                        onClick={() => handleDownload(proof.id)}
                      >
                        <FiDownload className="me-1" />
                        Descargar
                      </Button>
                      <Button 
                        variant="outline-success" 
                        size="sm"
                        onClick={() => handleUnarchive(proof.id)}
                      >
                        <FiRefreshCw className="me-1" />
                        Desarchivar
                      </Button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </Card.Body>
      </Card>
    </Col>
  </Row>
)}
```

## üîÑ Flujo de Trabajo

### 1. Archivar Comprobante
1. **Usuario hace clic** en "Archivar" en un comprobante aprobado
2. **Confirmaci√≥n** mediante modal de confirmaci√≥n
3. **Indicador visual** muestra "Archivando..." con spinner
4. **Petici√≥n al backend** para archivar el comprobante
5. **Actualizaci√≥n inmediata** del estado local:
   - Remueve de "Comprobantes Aprobados"
   - Agrega a "Comprobantes Archivados"
6. **Mensaje de √©xito** y restauraci√≥n del bot√≥n

### 2. Desarchivar Comprobante
1. **Usuario hace clic** en "Desarchivar" en un comprobante archivado
2. **Confirmaci√≥n** mediante modal de confirmaci√≥n
3. **Indicador visual** muestra "Desarchivando..." con spinner
4. **Petici√≥n al backend** para desarchivar el comprobante
5. **Actualizaci√≥n inmediata** del estado local:
   - Remueve de "Comprobantes Archivados"
   - Agrega a "Comprobantes Aprobados"
6. **Mensaje de √©xito** y restauraci√≥n del bot√≥n

## üõ°Ô∏è Validaciones y Seguridad

### Backend
- ‚úÖ **Solo comprobantes aprobados** pueden ser archivados
- ‚úÖ **Solo comprobantes no archivados** pueden ser archivados
- ‚úÖ **Transacciones seguras** con rollback autom√°tico
- ‚úÖ **Validaci√≥n de permisos** por rol de usuario
- ‚úÖ **Mensajes de error espec√≠ficos** para diferentes casos

### Frontend
- ‚úÖ **Confirmaci√≥n obligatoria** antes de archivar/desarchivar
- ‚úÖ **Prevenci√≥n de doble-clic** con botones deshabilitados
- ‚úÖ **Indicadores visuales** durante operaciones
- ‚úÖ **Manejo de errores** con mensajes informativos
- ‚úÖ **Actualizaci√≥n optimista** del estado local

## üìä Beneficios del Sistema

### Para los Usuarios
- **üéØ Interfaz limpia**: Los comprobantes archivados no saturan la vista principal
- **‚ö° Respuesta inmediata**: No hay esperas ni recargas de p√°gina
- **üëÅÔ∏è Feedback visual**: Indicadores claros del estado de las operaciones
- **üîÑ Reversibilidad**: Los comprobantes se pueden desarchivar f√°cilmente

### Para el Sistema
- **üìà Escalabilidad**: Manejo eficiente de grandes cantidades de comprobantes
- **üóÑÔ∏è Organizaci√≥n**: Separaci√≥n clara entre comprobantes activos y archivados
- **üìä Trazabilidad**: Registro de qui√©n y cu√°ndo archiv√≥ cada comprobante
- **üîç Filtrado**: Posibilidad de filtrar comprobantes archivados por fecha y usuario

## üöÄ Caracter√≠sticas T√©cnicas

### Optimizaciones Implementadas
- **üîÑ Actualizaci√≥n optimista**: Cambios inmediatos en la interfaz
- **üì° Peticiones as√≠ncronas**: No bloquean la interfaz de usuario
- **üíæ Estado local inteligente**: Sincronizaci√≥n autom√°tica con el backend
- **üé® UX mejorada**: Indicadores de progreso y confirmaciones

### Arquitectura
- **üèóÔ∏è Patr√≥n MVC**: Separaci√≥n clara de responsabilidades
- **üîí Transacciones**: Integridad de datos garantizada
- **üìä √çndices optimizados**: Consultas eficientes en la base de datos
- **üéØ RESTful API**: Endpoints bien estructurados y documentados

## üìù Notas de Implementaci√≥n

### Archivos Modificados
- `backend/models/paymentProof.js` - Funciones de archivado
- `backend/controllers/paymentProofController.js` - Controladores de archivado
- `backend/routes/paymentProofRoutes.js` - Rutas de archivado
- `frontend/src/pages/ComprobantesPago.jsx` - Interfaz de archivado

### Scripts de Base de Datos
- `backend/sql/add_archive_column.sql` - Agregar columnas de archivado
- `backend/add-archive-columns.js` - Script de aplicaci√≥n

### Dependencias
- **Backend**: PostgreSQL, Node.js, Express
- **Frontend**: React, Bootstrap, React Icons
- **Base de datos**: √çndices optimizados para consultas de archivado

---

## üéâ Conclusi√≥n

El sistema de archivado de comprobantes de pago est√° completamente implementado y funcional. Proporciona una experiencia de usuario fluida y eficiente, con actualizaciones inmediatas de la interfaz y manejo robusto de errores. El sistema es escalable, seguro y f√°cil de mantener.

**Fecha de implementaci√≥n**: 2025-01-27  
**Versi√≥n**: 1.0.0  
**Estado**: ‚úÖ Completado y funcional
